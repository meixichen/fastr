#' Fit a latent factor model to single or multiple neuron spike trains
#'
#' @param data A `n_cell x n_bin x n_trial` (multiple neurons)  or `n_bin x n_trial` 
#' (single neuron) array of binary spike trains. See details for if the spike train
#' data is in the form of spike times.
#' @param dt Scalar. Length of each time bin for time discretization of spike trains.
#' @param n_factor Integer. Number of independent factors in factor analysis.
#' @param init A named list of initial values for the parameter vectors `log_a` and
#' `log_k`  both of length `n_cell`, and the lower triangular entries of the loading
#' matrix `Lt` of length `n_cell*n_factor-n_factor*(n_factor-1)/2`. 
#' Optionally the initial values of the latent path states can also be provided
#' in the list named as `x` which should be the same dimension as `data`. 
#' It `x` is not provided, initial values will be generated by bridge sampling.
#' If `method="2steps"`, only the initial values for the lower triangular loading 
#' matrix can to be provided in the form of `list(Lt = Lt_init_values)`. Default is
#' `list(Lt=rep(1, n_cell*n_factor-n_factor*(n_factor-1)/2))` if 2-step method is used,
#' or 
#' `list(log_k=logk_mle, log_a=loga_mle, Lt=rep(1, n_cell*n_factor-n_factor*(n_factor-1)/2))` if joint method is used.
#' @param method Estimation method: "2step" or "joint". 
#' Default is "2step" : the first step is estimating drift `a` and threshold `k`
#' marginally using an inverse Gaussian model for each neuron independently, and the
#' second step is estimating the factor loading matrix with `a_hat` and `k_hat` as 
#' plug-ins the joint likelihood. "joint" method estimates all parameters jointly,
#' hence more computationally intensive. 
#' @param lam Scalar. Penalization parameter for the loading matrix elements. Default
#' is `lam=ifelse(n_cell<10, 1, 0.5)`.
#' @param nu Scalar. Parameter that controls the "steepness" around 0 of the sigmoid 
#' function applied at the spike data likelihood layer. Default is 15. 
#' @param woodbury Use the Woodbury matrix identity to speed up the calculation of
#' the covariance matrix? Default is T.
#' @param silent Suppress model fitting messages?
#' @param adfun_only Only outputs of ADFun created by TMB? This is for debugging
#' purposes only. 
#' @param control A list of control parameters to pass to `nlminb()`.
#' @param ... Additional arguments to be passed to the optimization function
#' `nlminb()`
#' @details If the spike train data comes in the form of spike times, it can be
#' converted to the format accepted by `fastr_fit()` using the function `num2bin()`.
#' @return A list of class `fastr_fit` containing the following objects:
#' - time: time taken for model fitting in seconds,
#' - log_a_hat: estimates of log drift parameters `a`,
#' - log_k_hat: estimates of log threshold parameters `k`,
#' - loga_se: standard errors of `log_a_hat`,
#' - logk_se: standard errors of `log_k_hat`,
#' - lmat_hat: estimate of the loading matrix L,
#' - lmat_varimax: Varimax-transformed loading matrix estimate,
#' - lmat_unnorm_hat: estimate of the unnormalized L
#' - lmat_unnorm_cov: covariance matrix of the unnormalized L,
#' - env: Other objects in the environment created during model fitting.
#' @export

fastr_fit <- function(data, dt, n_factor, init=NULL, method="2step", lam=NULL, nu=15,
		   woodbury=T, silent=F, adfun_only=F, 
		   control=list(eval.max=500, iter.max=500), ...){
  n_cell <- dim(data)[1]
  n_bin <- dim(data)[2]
  n_trial <- dim(data)[3]
  
  # Get k and a MLE
  all_mle <- get_ig_mle(data, dt)
  log_k_hat <- all_mle$log_k
  log_a_hat <- all_mle$log_a
  hess <- all_mle$hess
  marg_cov <- solve(-hess)
  logk_se <- diag(marg_cov)[1:n_cell]
  loga_se <- diag(marg_cov)[(n_cell+1):(2*n_cell)]
  
  if (method == "2step"){
    if (is.null(init)){
      Lt <- rep(1, n_cell*n_factor-n_factor*(n_factor-1)/2) 
    }
    else{
      Lt <- init$Lt
    }
    if (is.null(init$x)){
      x <- prop_paths(data, dt, log_k_hat, log_a_hat)
    }
    else{
      x <- init$x
    }
    init_param <- list(log_k = log_k_hat,
		       log_a = log_a_hat,
		       Lt = Lt,
		       x = x)
    map <- list(log_k=rep(factor(NA), n_cell),
                log_a=rep(factor(NA), n_cell))		       
  }
  else if (method == "joint"){
    if (is.null(init)){
      init_param <- list(log_k = log_k_hat,
			 log_a = log_a_hat,
                         Lt = rep(1, n_cell*n_factor-n_factor*(n_factor-1)/2), 
			 x = prop_paths(data, dt, log_k_hat, log_a_hat))
    }
    else{
      if (is.null(init$x)){
        x <- prop_paths(data, dt, init$log_k, init$log_a)
      }
      else{
 	x <- init$x
      }
      init_param <- list(log_k = init$log_k,
			 log_a = init$log_a,
			 Lt = init$Lt,
			 x = x)
    }
    map <- NULL
  }
  else{
    stop("method must be one of '2step' or 'joint'.")
  }
 

  model_choice <- ifelse(woodbury, "factor_model_eff", "factor_model")
  lam <- ifelse(n_cell<10, 1, 0.5)
  data <- list(model=model_choice, n_factor=n_factor, dt=dt, Y=data, 
	       lam=as.double(lam), nu=as.double(nu))
  
  if (!silent) cat("Building the ADFun...\n")
  adfun <- TMB::MakeADFun(data=data,
                          parameters=init_param,
			  map = map,
			  random = "x",
			  DLL = "fastr_TMBExports",
			  silent = silent)
  if (!adfun_only){
    start_t <- Sys.time()
    fit <- nlminb(adfun$par, adfun$fn, adfun$gr, control=control)
    time_nlminb <- difftime(Sys.time(), start_t, units="secs")
    if (!silent) cat("Finished optimization. Starting sdreport...\n")
    rep <- TMB::sdreport(adfun, getJointPrecision = TRUE)
    time_sdrep <- difftime(Sys.time(), start_t, units="secs") - time_nlminb
    if (method == "joint"){
      k_ind <- which(names(fit$par)=="log_k")
      a_ind <- which(names(fit$par)=="log_a")
      log_k_hat <- fit$par[k_ind]
      log_a_hat <- fit$par[a_ind]
      all_se <- diag(rep$cov.fixed)
      logk_se <- all_se[k_ind]
      loga_se <- all_se[a_ind]
    }
    t_taken <- as.numeric(difftime(Sys.time(), start_t, units="secs"))
    lmat_hat <- get_FA_estim(fit, n_cell=n_cell, n_factor=n_factor)$L
    lmat_varimax <- varimax(lmat_hat)$loadings[1:n_cell,]
    lmat_unnorm_hat <- rep$par.fixed[which(names(rep$par.fixed)=="Lt")]
    lmat_unnorm_cov <- rep$cov.fixed[which(colnames(rep$cov.fixed)=="Lt"),
				     which(colnames(rep$cov.fixed)=="Lt")] 
    env <- list(start_time = start_t,
		time_nlminb = time_nlminb,
		time_sdrep = time_sdrep,
                nlminb_fit = fit,
                tmb_report = rep,
                n_factor = n_factor,
                n_cell = n_cell,
                n_bin = n_bin,
                n_trial = n_trial,
                dt = dt)
    out <- list(time = t_taken,
		log_k_hat = log_k_hat,
		log_a_hat = log_a_hat,
	        logk_se = logk_se,
		loga_se = loga_se,
		marg_cov = marg_cov,
		lmat_hat = lmat_hat,
		lmat_varimax = lmat_varimax,
		lmat_unnorm_hat = lmat_unnorm_hat,
		lmat_unnorm_cov = lmat_unnorm_cov,
		env = env)
    class(out) <- "fastr_fit"
    return(out)    
  }
  else{
    return(adfun)
  }  
}
